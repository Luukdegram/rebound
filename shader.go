package rebound

import (
	"fmt"
	"strings"

	"github.com/go-gl/gl/v4.1-core/gl"
	"github.com/luukdegram/rebound/internal/thread"
)

const (
	//FragmentShader is a default fragmentation shader.
	//It supports lights, skycolour, reflectivity, shinedamper.
	FragmentShader = `
	#version 410 core
	in vec2 pass_textureCoords;
	in vec3 surfaceNormal;
	in vec3 lightVec;
	in vec3 cameraVec;
	in float visibility;
	
	out vec4 frag_colour;
	
	uniform sampler2D textureSampler;
	uniform vec3 lightColour;
	uniform float shineDamper;
	uniform float reflectivity;
	uniform vec3 skyColour;
	
	void main() {
		vec3 unitNormal = normalize(surfaceNormal);
		vec3 unitLightVector = normalize(lightVec);
	
		float nDot = dot(unitNormal, unitLightVector);
		float brightness = max(nDot, 0.2);
		vec3 diffuse = brightness * lightColour;
	
		vec3 unitCameraVector = normalize(cameraVec);
		vec3 lightDirection = -unitLightVector;
		vec3 reflectedLightDirection = reflect(lightDirection, unitNormal);
	
		float specularFactor = dot(reflectedLightDirection, unitCameraVector);
		specularFactor = max(specularFactor, 0.0);
		float dampedFactor = pow(specularFactor, shineDamper);
		vec3 finalSpecular = dampedFactor * reflectivity * lightColour;
	
		vec4 textureColor = texture(textureSampler, pass_textureCoords);
		if (textureColor.a < 0.5) {
			discard;
		}
	
		frag_colour = vec4(diffuse, 1.0) * textureColor + vec4(finalSpecular, 1.0);
		frag_colour = mix(vec4(skyColour, 1.0), frag_colour, visibility);
	}
	` + "\x00"

	//VertexShader is a default vertex shader.
	//It allows visibility turn on/off, a camera and fake lighting
	VertexShader = `
	#version 410 core
	layout (location = 0) in vec3 position;
	layout (location = 1) in vec2 textureCoords;
	layout (location = 2) in vec2 textureCoords2;
	layout (location = 3) in vec3 normal;
	layout (location = 4) in vec4 tangents;
	layout (location = 5) in vec4 color;
	layout (location = 6) in vec4 joints;
	layout (location = 7) in vec4 weights;
	
	out vec2 pass_textureCoords;
	out vec3 surfaceNormal;
	out vec3 lightVec;
	out vec3 cameraVec;
	out float visibility;
	
	uniform mat4 transformMatrix;
	uniform mat4 projectionMatrix;
	uniform mat4 viewMatrix;
	uniform vec3 lightPos;
	
	uniform float useFakeLighting;
	
	const float density = 0.07;
	const float gradient = 1.5;
	
	void main(void) {
		vec4 worldPos = transformMatrix * vec4(position, 1.0);
		vec4 positionRelativeToCam = viewMatrix * worldPos;
		gl_Position = projectionMatrix * positionRelativeToCam;
		pass_textureCoords = textureCoords;
	
		vec3 actualNormal = normal;
		if (useFakeLighting > 0.5) {
			actualNormal = vec3(0.0, 1.0, 0.0);
		}
	
		surfaceNormal = (transformMatrix * vec4(actualNormal, 0.0)).xyz;
		lightVec = lightPos - worldPos.xyz;
		cameraVec = (inverse(viewMatrix) * vec4(0,0,0,1)).xyz - worldPos.xyz;
	
		float dist = length(positionRelativeToCam.xyz);
		visibility = exp(-pow((dist*density), gradient));
		visibility = clamp(visibility, 0.0, 1.0);
	}` + "\x00"
)

var shaderIds []uint32

// Shader contains the logic to render a shader
type Shader interface {
	// Setup runs at the beginning of the renderer's update() function, before any entities are being rendered.
	// The camera is provided to retreive its view and projection matrixes
	Setup(Camera)
	// Render runs while rendering each entity, the corresponding RenderComponent is provided in the Render runction.
	// Within this function you can set entity specific shader options
	Render(RenderComponent)
	// ID returns the shader's ID, this is generated by the NewShader function
	ID() uint32
}

// BasicShader is the default shader part of the Rebound engine.
type BasicShader struct {
	id           uint32
	ShineDamper  float32
	Reflectivity float32
	Light        *Light
	SkyColour    [3]float32
}

//NewShader returns a new ShaderComponent by compiling the given vertexShader and fragmentShader
//Returns an error if any of the shaders could not be compiled
func NewShader(vertexShader, fragmentShader string) (id uint32, err error) {
	err = thread.CallErr(func() error {
		vID, err := compileShader(vertexShader, gl.VERTEX_SHADER)
		if err != nil {
			return err
		}

		shaderIds = append(shaderIds, vID)

		fID, err := compileShader(fragmentShader+"\x00", gl.FRAGMENT_SHADER)
		if err != nil {
			return err
		}

		shaderIds = append(shaderIds, fID)

		id = gl.CreateProgram()
		gl.AttachShader(id, vID)
		gl.AttachShader(id, fID)

		gl.LinkProgram(id)
		gl.ValidateProgram(id)

		gl.DetachShader(id, vID)
		gl.DetachShader(id, fID)

		return nil
	})

	return
}

// NewBasicShader creates a default shader, provided by the Rebound engine
func NewBasicShader() (*BasicShader, error) {
	id, err := NewShader(VertexShader, FragmentShader)
	if err != nil {
		return nil, err
	}

	bs := &BasicShader{
		id,
		1000,
		1,
		&Light{
			Position: [3]float32{3000, 2000, 2000},
			Colour:   [3]float32{1, 1, 1},
		},
		[3]float32{0.5, 0.5, 0.5},
	}

	return bs, nil
}

// ID returns the shader id generated by opengl
func (bs *BasicShader) ID() uint32 {
	return bs.id
}

// Setup loads variables into the shader pre-entity rendering
func (bs *BasicShader) Setup(c Camera) {
	if bs.Light != nil {
		LoadVec3(bs, "lightPos", bs.Light.Position)
		LoadVec3(bs, "lightColour", bs.Light.Colour)
	}

	LoadVec3(bs, "skyColour", bs.SkyColour)
	LoadMat(bs, "projectionMatrix", c.ProjectMat)
	LoadMat(bs, "viewMatrix", NewViewMatrix(c))
	LoadFloat(bs, "shineDamper", bs.ShineDamper)
	LoadFloat(bs, "reflectivity", bs.Reflectivity)
}

// Render loads variables into the shader based on current RenderComponent
func (bs *BasicShader) Render(rc RenderComponent) {
	if rc.Material.Transparent {
		LoadBool(bs, "useFakeLighting", true)
	} else {
		LoadBool(bs, "useFakeLighting", false)
	}

	tmMat := NewTransformationMatrix(rc.Position, rc.Rotation, rc.Scale)
	LoadMat(bs, "transformMatrix", tmMat)
}

//GetUniformLocation returns the location of the uniform given, returning the OpenGL id as an int32
func GetUniformLocation(s Shader, name string) int32 {
	return gl.GetUniformLocation(s.ID(), gl.Str(name+"\x00"))
}

//LoadFloat loads a uniform float into the shader
func LoadFloat(s Shader, name string, value float32) {
	loc := GetUniformLocation(s, name)
	gl.Uniform1f(loc, value)
}

//LoadVec3 loads a uniform Vector into the shader
func LoadVec3(s Shader, name string, value [3]float32) {
	loc := GetUniformLocation(s, name)
	gl.Uniform3f(loc, value[0], value[1], value[2])
}

//LoadBool loads a boolean into the shader
func LoadBool(s Shader, name string, value bool) {
	loc := GetUniformLocation(s, name)
	var float float32
	if value {
		float = 1
	}
	gl.Uniform1f(loc, float)
}

//LoadMat loads a matrix into the shader
func LoadMat(s Shader, name string, value [16]float32) {
	loc := GetUniformLocation(s, name)
	gl.UniformMatrix4fv(loc, 1, false, &value[0])
}

//Start starts the shader program
func Start(s Shader) {
	gl.UseProgram(s.ID())
}

//Stop stops the current shader program
func Stop() {
	gl.UseProgram(0)
}

//CleanUpShaders deletes the program
func CleanUpShaders() {
	thread.Call(func() {
		for _, id := range shaderIds {
			gl.DeleteProgram(id)
		}

		for _, id := range shaderIds {
			gl.DeleteShader(id)
		}
	})
}

func compileShader(source string, shaderType uint32) (uint32, error) {
	shader := gl.CreateShader(shaderType)

	csources, free := gl.Strs(source)
	gl.ShaderSource(shader, 1, csources, nil)
	free()
	gl.CompileShader(shader)

	var status int32
	gl.GetShaderiv(shader, gl.COMPILE_STATUS, &status)
	if status == gl.FALSE {
		var logLength int32
		gl.GetShaderiv(shader, gl.INFO_LOG_LENGTH, &logLength)

		log := strings.Repeat("\x00", int(logLength+1))
		gl.GetShaderInfoLog(shader, logLength, nil, gl.Str(log))

		return 0, fmt.Errorf("failed to compile %v: %v", source, log)
	}
	return shader, nil
}
